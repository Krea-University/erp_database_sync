#!/usr/bin/env bash
# =============================================================================
#  setup.sh  –  One-time setup:
#    1. Validate environment
#    2. Start local MySQL via Docker Compose
#    3. Create MySQL users from MYSQL_USERS_JSON in .env
#    4. Run the application Docker image
#    5. Register a cron job for sync.sh every 2-3 hours
#    6. Trigger the first sync immediately
# =============================================================================
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
ENV_FILE="${SCRIPT_DIR}/.env"

# ── 0. Load .env ──────────────────────────────────────────────────────────────
if [[ ! -f "$ENV_FILE" ]]; then
  echo "[ERROR] .env not found. Copy .env.example → .env and fill it in."
  exit 1
fi
# shellcheck disable=SC1090
source "$ENV_FILE"

log() { echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*"; }

# ── 1. Dependency checks ──────────────────────────────────────────────────────
log "Checking dependencies …"
for cmd in docker docker-compose jq mysqldump gcloud; do
  if ! command -v "$cmd" &>/dev/null; then
    echo "[ERROR] Required command not found: $cmd"
    exit 1
  fi
done
log "All dependencies present."

# ── 2. Start MySQL + networking via Docker Compose ────────────────────────────
log "Starting local MySQL container …"
docker-compose -f "${SCRIPT_DIR}/docker-compose.yml" up -d mysql_local

# Wait until MySQL is accepting connections
log "Waiting for MySQL to be ready …"
RETRIES=30
until docker exec mysql_local \
    mysqladmin ping -uroot -p"${MYSQL_ROOT_PASSWORD}" --silent 2>/dev/null; do
  RETRIES=$((RETRIES - 1))
  if [[ $RETRIES -eq 0 ]]; then
    log "[ERROR] MySQL did not become ready in time."
    exit 1
  fi
  sleep 2
done
log "MySQL is ready."

# ── 3. Create MySQL users from MYSQL_USERS_JSON ───────────────────────────────
log "Creating MySQL users from MYSQL_USERS_JSON …"

# Validate JSON
if ! echo "${MYSQL_USERS_JSON}" | jq empty 2>/dev/null; then
  log "[ERROR] MYSQL_USERS_JSON in .env is not valid JSON."
  exit 1
fi

USER_COUNT=$(echo "${MYSQL_USERS_JSON}" | jq 'length')
log "Found ${USER_COUNT} user(s) to create."

for i in $(seq 0 $((USER_COUNT - 1))); do
  DB_USER=$(echo "${MYSQL_USERS_JSON}"       | jq -r ".[$i].user")
  DB_PASS=$(echo "${MYSQL_USERS_JSON}"       | jq -r ".[$i].password")
  DB_HOST=$(echo "${MYSQL_USERS_JSON}"       | jq -r ".[$i].host")
  DB_PRIVS=$(echo "${MYSQL_USERS_JSON}"      | jq -r ".[$i].privileges")
  TARGET_DB=$(echo "${MYSQL_USERS_JSON}"     | jq -r ".[$i].database // \"*\"")

  log "  → User: '${DB_USER}'@'${DB_HOST}'  privileges: ${DB_PRIVS} on ${TARGET_DB}.*"

  docker exec mysql_local mysql \
    -uroot -p"${MYSQL_ROOT_PASSWORD}" \
    -e "
      CREATE USER IF NOT EXISTS '${DB_USER}'@'${DB_HOST}'
        IDENTIFIED BY '${DB_PASS}';
      GRANT ${DB_PRIVS}
        ON \`${TARGET_DB}\`.*
        TO '${DB_USER}'@'${DB_HOST}';
      FLUSH PRIVILEGES;
    " 2>&1
done

log "User creation complete."

# ── 4. Write credentials .env summary (for app containers) ───────────────────
CREDS_FILE="${SCRIPT_DIR}/.credentials.env"
log "Writing credentials summary to ${CREDS_FILE} …"
cat > "$CREDS_FILE" <<EOF
# Auto-generated by setup.sh – $(date)
# DO NOT COMMIT THIS FILE
MYSQL_HOST=mysql_local
MYSQL_PORT=${MYSQL_PORT}
MYSQL_DATABASE=${MYSQL_DATABASE}
MYSQL_ROOT_PASSWORD=${MYSQL_ROOT_PASSWORD}
MYSQL_USERS_JSON=${MYSQL_USERS_JSON}
EOF

# Build per-user flat vars for convenience
i=0
while IFS= read -r row; do
  u=$(echo "$row" | jq -r '.user')
  p=$(echo "$row" | jq -r '.password')
  h=$(echo "$row" | jq -r '.host')
  {
    echo "DB_USER_${i}_NAME=${u}"
    echo "DB_USER_${i}_PASS=${p}"
    echo "DB_USER_${i}_HOST=${h}"
  } >> "$CREDS_FILE"
  i=$((i+1))
done < <(echo "${MYSQL_USERS_JSON}" | jq -c '.[]')

log "Credentials written to ${CREDS_FILE}"

# ── 5. Run application Docker image ──────────────────────────────────────────
log "Starting application container '${APP_CONTAINER_NAME}' …"

# Stop + remove existing container with same name (idempotent)
docker rm -f "${APP_CONTAINER_NAME}" 2>/dev/null || true

docker run -d \
  --name "${APP_CONTAINER_NAME}" \
  --network "${DOCKER_NETWORK}" \
  --env-file "${CREDS_FILE}" \
  -e MYSQL_HOST=mysql_local \
  -e MYSQL_PORT="${MYSQL_PORT}" \
  -e MYSQL_DATABASE="${MYSQL_DATABASE}" \
  -p "${APP_PORT}:${APP_PORT}" \
  --restart unless-stopped \
  "${APP_DOCKER_IMAGE}"

log "Application container started (image: ${APP_DOCKER_IMAGE}, port: ${APP_PORT})."

# ── 6. Register cron job ──────────────────────────────────────────────────────
log "Configuring cron job for sync.sh …"

SYNC_SCRIPT="${SCRIPT_DIR}/sync.sh"
chmod +x "$SYNC_SCRIPT"

# Determine cron expression
if [[ -n "${SYNC_CRON_OVERRIDE:-}" ]]; then
  CRON_EXPR="${SYNC_CRON_OVERRIDE}"
  log "Using custom cron override: ${CRON_EXPR}"
else
  HOURS="${SYNC_INTERVAL_HOURS:-2}"
  # Run at minute 0 every HOURS hours  (e.g. 0 */2 * * *)
  CRON_EXPR="0 */${HOURS} * * *"
  log "Auto cron expression: '${CRON_EXPR}'  (every ${HOURS} hours)"
fi

CRON_LOG="${LOG_DIR:-/var/log/erp_sync}/cron.log"
mkdir -p "$(dirname "$CRON_LOG")"

CRON_LINE="${CRON_EXPR} /usr/bin/env bash ${SYNC_SCRIPT} >> ${CRON_LOG} 2>&1"
CRON_MARKER="# erp_database_sync"

# Idempotent: remove old entry, add new one
(
  crontab -l 2>/dev/null | grep -v "$CRON_MARKER" || true
  echo "${CRON_MARKER}"
  echo "${CRON_LINE}"
) | crontab -

log "Cron job registered:"
log "  ${CRON_LINE}"

# ── 7. First sync ─────────────────────────────────────────────────────────────
log "Running initial sync now …"
bash "$SYNC_SCRIPT"

log ""
log "╔══════════════════════════════════════════════════════╗"
log "║           Setup Complete – Summary                   ║"
log "╠══════════════════════════════════════════════════════╣"
log "║  MySQL (local)   : localhost:${MYSQL_PORT}                    ║"
log "║  Database        : ${MYSQL_DATABASE}                  ║"
log "║  App container   : ${APP_CONTAINER_NAME} → :${APP_PORT}        ║"
log "║  Sync schedule   : ${CRON_EXPR}               ║"
log "║  Credentials     : ${CREDS_FILE}    ║"
log "║  Logs            : ${LOG_DIR:-/var/log/erp_sync}             ║"
log "╚══════════════════════════════════════════════════════╝"
